# Friday, March 28 2025

## Tasks

- [] March 28, 2025 - Task: till sleep finish as many videos possible dont stop rock on
- [>] March 28, 2025 - Task: prepare your resume in ats form and apply to few jobs (moved: 2025-03-29)



## Notes

### Remove Duplicates from Sorted Array

Problem Statement

Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.
Solutions
1. Brute Force Approach (Using Extra Space)


```

def remove_duplicates_brute(nums):
    if not nums:
        return 0
    
    unique = []
    for num in nums:
        if num not in unique:
            unique.append(num)
    
    #  back to original array
    for i in range(len(unique)):
        nums[i] = unique[i]
    
    return len(unique)

```
Time Complexity: O(n²)
Space Complexity: O(n)

Explanation: We check each element against all previous elements, making it O(n²). We also use extra space for the unique list.
2. Better Approach (Using Set)



```
def remove_duplicates_better(nums):
    unique = list(sorted(set(nums)))
    for i in range(len(unique)):
        nums[i] = unique[i]
    return len(unique)
```

Time Complexity: O(n log n)
Space Complexity: O(n)
Explanation: Converting to set removes duplicates but loses order, so we need to sort again. Still uses extra space.
3. Optimal Approach (Two Pointers - In Place)



```
def remove_duplicates_optimal(nums):
    if not nums:
        return 0
    
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    
    return slow + 1
```

Time Complexity: O(n)
Space Complexity: O(1)
Explanation: Uses two pointers to track unique elements in a single pass through the array. Modifies the array in-place without extra space.

### Left Rotate an Array by 1 Place

1. Brute Force Approach (Using Extra Array)
python
Copy

def left_rotate_brute(arr):
    n = len(arr)
    if n <= 1:
        return arr
    
    rotated = [0] * n
    rotated[-1] = arr[0]  # Move first element to last position
    
    for i in range(1, n):
        rotated[i-1] = arr[i]  # Shift remaining elements left
    
    return rotated

Time Complexity: O(n)
Space Complexity: O(n)
Explanation: Creates a new array to store rotated elements.
2. Optimal Approach (In-Place Rotation)
python
Copy

def left_rotate_optimal(arr):
    n = len(arr)
    if n <= 1:
        return arr
    
    first_element = arr[0]
    
    for i in range(n-1):
        arr[i] = arr[i+1]  # Shift elements left
    
    arr[-1] = first_element  # Place first element at end
    
    return arr

Time Complexity: O(n)
Space Complexity: O(1)
Explanation: Modifies array in-place with constant extra space.


### Left Rotate an Array by K Places

Problem Statement

Given an array and a number k, rotate the array to the left by k positions.
Solutions
1. Brute Force Approach (Rotate One-by-One)
python
Copy

def left_rotate_k_brute(arr, k):
    n = len(arr)
    k = k % n  # Handle cases where k > n
    for _ in range(k):
        first = arr[0]
        for i in range(n-1):
            arr[i] = arr[i+1]
        arr[-1] = first
    return arr

Time Complexity: O(n*k)
Space Complexity: O(1)
Explanation: Rotates the array left by 1 position, k times. Inefficient for large k.
2. Better Approach (Using Extra Space)
python
Copy

def left_rotate_k_better(arr, k):
    n = len(arr)
    k = k % n
    temp = arr[:k]  # Store first k elements
    for i in range(n - k):
        arr[i] = arr[i + k]  # Shift remaining elements
    arr[-k:] = temp  # Place stored elements at end
    return arr

Time Complexity: O(n)
Space Complexity: O(k)
Explanation: Uses temporary storage for first k elements.
3. Optimal Approach (**Reversal Algorithm**)
python
Copy

def left_rotate_k_optimal(arr, k):
    n = len(arr)
    k = k % n
    
    # Reverse first k elements
    arr[:k] = arr[:k][::-1]
    # Reverse remaining elements
    arr[k:] = arr[k:][::-1]
    # Reverse entire array
    arr[:] = arr[::-1]
    
    return arr

Time Complexity: O(n)
Space Complexity: O(1)
Explanation: Uses array reversal to achieve rotation in-place with constant space.


### Move All Zeroes to End of Array

Problem Statement

Given an integer array, move all 0's to the end while maintaining the relative order of non-zero elements.
Solutions
1. Brute Force Approach (Using Extra Space)
python
Copy

def move_zeroes_brute(nums):
    non_zero = []
    zero_count = 0
    
    for num in nums:
        if num != 0:
            non_zero.append(num)
        else:
            zero_count += 1
    
    nums[:] = non_zero + [0] * zero_count
    return nums

Time Complexity: O(n)
Space Complexity: O(n)
Explanation: Creates new lists for non-zero elements and zeros.

2. Optimal Approach (Two Pointers - In Place)

def move_zeroes_optimal(nums):
    slow = 0
    for fast in range(len(nums)):
        if nums[fast] != 0:
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow += 1
    return nums
    
How It Works (Step-by-Step):

    Initialization:

        slow pointer starts at index 0 (will track position for next non-zero)

        fast pointer iterates through the array (current element being checked)

    Iteration:

        The fast pointer moves through each element in the array

        When nums[fast] is non-zero:
        a. We swap it with nums[slow] (moves non-zero to front)
        b. Increment slow (now points to next position for non-zero)

    Result:

        All non-zero elements get moved to the front in original order

        Zeros automatically end up at the end due to the swapping

Time Complexity: O(n)
Space Complexity: O(1)
Explanation: Uses two pointers to swap non-zero elements forward.

3. Alternative Approach (Count and Fill)

def move_zeroes_alternative(nums):
    pos = 0
    for num in nums:
        if num != 0:
            nums[pos] = num
            pos += 1
    
    while pos < len(nums):
        nums[pos] = 0
        pos += 1
    
    return nums

Time Complexity: O(n)
Space Complexity: O(1)
Explanation: First moves non-zero elements, then fills remaining with zeros.


#### Time complexity calculation for set to list

```python
def remove_duplicates_better(nums):
    unique = list(sorted(set(nums)))  # Line 1
    for i in range(len(unique)):      # Line 2
        nums[i] = unique[i]           # Line 3
    return len(unique)                # Line 4

Line-by-Line Complexity Analysis:

    unique = list(sorted(set(nums)))

        set(nums): O(n) - Converting list to set (hash table insertion)

        sorted(): O(m log m) - Sorting the unique elements, where m = number of unique elements

        list(): O(m) - Converting back to list

        Total for Line 1: O(n) + O(m log m) + O(m) → O(n + m log m)
```


