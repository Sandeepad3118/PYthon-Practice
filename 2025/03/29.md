# Saturday, March 29 2025

## Tasks

- [] March 29, 2025 - Task:  Till 29 finish properly by morning before start of match
- [] March 28, 2025 - Task: March 28, 2025 - Task: prepare your resume in ats form and apply to few jobs
- [] March 28, 2025 - Task: March 28, 2025 - Task: get flutter up and running


## Notes

### Given an array of size N containing distinct integers from 0 to N (with one number missing), find the missing number.

```python
def miss_elem(arr,n):
    for i in range(n+1):
        if i not in arr:
            return i

// Using hash array

def miss_elem(arr,n):
    hash_arr=[0]*(n+1)
    for i in range(len(arr)):
        hash_arr[arr[i]]=1
    for i in range(1,len(hash_arr)):
        if hash_arr[i]==0:
            print(i)

// hash set

def missing_number_hash(nums):
    num_set = set(nums)
    n = len(nums)
    for i in range(n + 1):
        if i not in num_set:
            return i
    return -1

Time Complexity: O(n)
Space Complexity: O(n)
Explanation: Converts array to set for O(1) lookups, then checks each number.


def miss_elem(arr,n):
    total_sum=arr_sum=0
    for i in range(n+1):
        total_sum+=i
    for i in range(len(arr)):   
        arr_sum+=arr[i]
    print(total_sum-arr_sum)


def missing_number_xor(nums):
    missing = len(nums)
    for i, num in enumerate(nums):
        missing ^= i ^ num
    return missing

Time Complexity: O(n)
Space Complexity: O(1)

arr=[5,1,2,4,0]
n=5
miss_elem(arr,n)
```

### Find the maximum number of consecutive 1's in a binary array

```python
def max_ones(arr):
    maxi = count = 0
    for num in arr:
        if num == 1:
            count += 1
            maxi = max(maxi, count)  # Update maxi whenever we see a 1
        else:
            count = 0
    return maxi
```

### Given a non-empty array of integers where every element appears twice except for one, find that single element.

```python
My brute force approach:

def present_once(arr):
    n=len(arr)
    arr.sort()
    i=0
    j=1
    if len(arr)=1:
        return arr[i]
    else
        return -1
    while i<n-1 and j<n:
        if arr[i]==arr[j]:
            i+=2
            j+=2
        else:
            return arr[i]

print(present_once([1,1,2,3,4,3,4]))

Brute Force Approach (Nested Loops)

def single_number_brute(nums):
    for i in range(len(nums)):
        found = False
        for j in range(len(nums)):
            if i != j and nums[i] == nums[j]:
                found = True
                break
        if not found:
            return nums[i]
    return -1  # Shouldn't reach here per problem statement

Time Complexity: O(nÂ²)
Space Complexity: O(1)
Explanation: For each element, checks if it appears again in the array.

Better Approach (Using Hash Map/Dictionary)
def single_number_hash(nums):
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    for num, count in freq.items():
        if count == 1:
            return num
    return -1

Time Complexity: O(n)
Space Complexity: O(n)
Explanation: Counts frequency of each number, then finds the one with count 1.

3. Optimal Approach (Bit Manipulation - XOR)

def single_number_xor(nums):
    result = 0
    for num in nums:
        result ^= num
    return result

Time Complexity: O(n)
Space Complexity: O(1)
Explanation: XOR all numbers - duplicates cancel out (a ^ a = 0), leaving the single number.
```