
# Tuesday, March 25 2025

# Tasks
- start with strivers videos(till 20) and jump into python gfg as and when needed
- in home hashing, maths, python concepts

# Failed part of Tasks
- stuck at sorting part of videos. have to revisit and understand it in  my own terms
- couldn't get to 20 videos
- no work done after coming to home

# Notes

# Time complexity
- rate at which the time taken to execute a piece of code with respect to input size
- 3 rules of time complexity
 - time compelxity to be computed for worst case scenario
 - avoid constants
 - avoid lower values
- we can calculate time complexity like below
````python
i=0 j={0}
i=1 j=(0,1)
i=2 j=(0,1,2)
i=3 j=(0,1,2,3)


i=n-1 j=(0,1,2,3,.....,n-1)

1+2+3+.....+n = n*(n+1)/2
````

# Space complexity
- memory space the program takes . varies from machine to machine
- Big O notation
space complexity = auxillary space(space taken to solve the problem) + input space(space taken to store the input)

```python
input(a,b)
c=a+b
AS = c
IS = a,b
SC = O(3)
```

Consider a function that reverses an array in-place:

def reverse_array(arr):
    left = 0
    right = len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    return arr

    Auxiliary Space: O(1) (only a few variables are used).

    Input Space: O(n) (the array itself).

    Total Space Complexity: O(n) (auxiliary + input).

But usually, we say this algorithm uses O(1) extra space (focusing on auxiliary space).


1 second = 10**8 operations on server of leetcode, hackerrank.. --> time complexity



## Recursion
- Function that calls itself until a specific condition is met


### recursion

def rec(i,n):
    if i>n:
        return
    print(i) # 1,2,3,4 ... n
    rec(i+1,n)

def rec(i,n):
    if i<1:
        return
    print(i) # n, n-1 ..... 2,1
    rec(i-1,n)


### Backtracking Recursion

def bactrac1(i,n):
    if i>n:
        return
    bactrac1(i+1,n)
    print(i) # n, n-1 ..... 2,1


def bactrac2(i,n):
    if i<1:
        return
    bactrac2(i-1,n)
    print(i) # 1,2,3,4 ... n

bactrac1(1,4)
bactrac2(4,4)

### parameterised Recurion(normal method)

```python
def par(i,sum):
    if i==0:
     print(sum)
     return
    par(i-1,sum+i)

n=int(input("enter a n value"))
par(n,0)

```

```python
def climb_stairs(n, memo=None):
    if memo is None:
        memo = {}
    if n in memo:
        return memo[n]
    if n <= 2:
        return n
    result = climb_stairs(n-1, memo) + climb_stairs(n-2, memo)
    memo[n] = result
    return result
print(climb_stairs(5))
```

### functional recursion(normal)

def par(n):
    if(n==1):
        return 1
    return n+par(n-1)

n=int(input("enter n"))
print(par(n))

## Reverse an array

### Brute force -- O(n/2)

def swap(a,n):
    for i in range(n//2):
     t=a[i]
     a[i] = a[n-(i+1)]
     a[n-(i+1)]=t
    print(a)
swap([1,2,3,4,5,6],6)

### parameterised function -- using two pointers

def f(l,r):
 if(l>=r):
  return 
 swap(a[l],a[r])
 f(l+1,r-1)

### check palindrome

def f(i,arr):
  if(i>=len(arr)//2):
    return True
  if(arr[i]!=arr[len(arr)-i-1]):
    return False
  return f(i+1,arr)

if __name__ == "__main__":
  arr = "MADAMA"
  print(f(0,arr))

### reverse of a string

```python
def f(i,arr,n):
  if(i>=n//2):
    return arr
  arr=swap(arr,i,n-i-1)
  return f(i+1,arr,n)


def swap(lst, index1, index2):
    lst[index1], lst[index2] = lst[index2], lst[index1]
    return lst

if __name__ == "__main__":
  arr = "carrot"
  print(f(0,list(arr),len(arr)))
  lst=f(0,list(arr),len(arr))
  print(''.join(lst)) #for items that all strings in list

mixed_list = [1, 'apple', True, 3.14]
result = ' '.join([str(item) for item in mixed_list])
print(result)  # Output: "1 apple True 3.14"
```

