# Sunday, March 30 2025

## Tasks

## Notes

### Longest Subarray with Sum K 

Given an array of positive integers, find the length of the longest subarray that sums to exactly K.
1. Brute Force Solution

Approach: Check all possible subarrays and find the longest one with sum K.
python
Copy

def longest_subarray_brute(arr, K):
    max_len = 0
    n = len(arr)
    
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += arr[j]
            if current_sum == K:
                max_len = max(max_len, j - i + 1)
            elif current_sum > K:
                break
    return max_len

# Time Complexity: O(n^2) - nested loops
# Space Complexity: O(1) - no extra space

2. Better Solution (Sliding Window)

Approach: Use sliding window technique since all numbers are positive. Expand window while sum ≤ K, shrink when sum > K.

def longest_subarray_better(arr, K):
    max_len = 0
    current_sum = 0
    left = 0
    
    for right in range(len(arr)):
        current_sum += arr[right]
        
        while current_sum > K and left <= right:
            current_sum -= arr[left]
            left += 1
            
        if current_sum == K:
            max_len = max(max_len, right - left + 1)
    
    return max_len

# Time Complexity: O(n) - each element processed at most twice
# Space Complexity: O(1) - constant space

3. Optimal Solution (Hash Map for general case)

Note: While the sliding window is optimal for positives, here's the hash map solution that works for both positive and negative numbers (for completeness)

The Key Idea (Prefix Sum + Hash Map)

Imagine you're walking through the array while keeping a running total (current_sum). At each step, you check if you've seen a sum that's exactly (current_sum - K) before. If you have, it means the elements between that previous point and now add up to K!

def longest_subarray_optimal(arr, K):
    prefix_sum = {0: -1}  # sum: index
    max_len = 0
    current_sum = 0
    
    for i in range(len(arr)):
        current_sum += arr[i]
        
        # If (current_sum - K) exists in map, we found a subarray
        if (current_sum - K) in prefix_sum:
            max_len = max(max_len, i - prefix_sum[current_sum - K])
        
        # Store the first occurrence of each sum
        if current_sum not in prefix_sum:
            prefix_sum[current_sum] = i
    
    return max_len

# Time Complexity: O(n) - single pass
# Space Complexity: O(n) - storing prefix sums

Comparison:

    Brute Force:

        Simple to implement

        Inefficient for large arrays (O(n²))

    Sliding Window (Better):

        Optimal for positive numbers only (O(n) time)

        Doesn't work if array contains zeros or negatives

    Hash Map (Optimal for general case):

        Works for any integers (positive, negative, zero)

        Requires O(n) space for hash map

For problems with only positive numbers, the sliding window approach is preferred due to its O(n) time and O(1) space complexity.

### Learning Hash map

Frequency Counter

def words_freq_counter(str):
    words=str.split()
    freq={}
    for word in words:
        if word not in freq:
            freq[word]+=1
    return freq


str="apple banana xy xy banana apple"
print(words_freq_counter(str))


All the content is in the UpNote section



### Count Subarray Sum Equals K | Brute - Better - Optimal

Given an array of integers nums and an integer k, we need to count the number of subarrays whose sum equals k.
Input: nums = [1, 2, 3], k = 3  
Output: 2  
Explanation:  
- Subarrays [1, 2] → sum = 3  
- Subarray [3] → sum = 3  
Total subarrays = 2

#### Brute Force Approach (O(N²) Time | O(1) Space)
Idea:
    Generate all possible subarrays and check if their sum equals k.
    Use nested loops to fix the start and end of each subarray.

Code:
def subarraySum(nums, k):
    count = 0
    n = len(nums)
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += nums[j]
            if current_sum == k:
                count += 1
    return count

Time Complexity:
    O(N²) because we check all possible subarrays.

Space Complexity:
    O(1) (no extra space used).

#### Better Approach (Using Prefix Sum + Hashmap) (O(N) Time | O(N) Space)
Idea:
    Prefix Sum: prefix[i] = sum(nums[0..i-1])
    Key Insight:
        If prefix[j] - prefix[i] = k, then the subarray nums[i..j-1] sums to k.
        We store prefix sums in a hashmap to count occurrences efficiently.

Code:
def subarraySum(nums, k):
    from collections import defaultdict
    prefix_sum = defaultdict(int)
    prefix_sum[0] = 1  # Empty subarray case
    current_sum = 0
    count = 0
    for num in nums:
        current_sum += num
        # Check if (current_sum - k) exists in prefix_sum
        count += prefix_sum.get(current_sum - k, 0)
        # Update prefix_sum with current_sum
        prefix_sum[current_sum] += 1
    return count

Explanation:
    prefix_sum[0] = 1:
        Handles the case where a subarray starts from index 0.
    current_sum:
        Tracks the cumulative sum up to the current index.
    count += prefix_sum.get(current_sum - k, 0):
        If current_sum - k exists in prefix_sum, it means there are subarrays ending at the current index that sum to k.
    Update prefix_sum:
        Store the frequency of each current_sum.

Time Complexity:
    O(N) (single pass over the array).

Space Complexity:
    O(N) (hashmap stores prefix sums).

#### Optimal Approach (Sliding Window - Works Only for Positive Numbers) (O(N) Time | O(1) Space)
Idea:
    Sliding Window works if all numbers are positive (since increasing window size increases sum).
    Adjust window size (left and right pointers) to maintain sum == k.

Code:
def subarraySum(nums, k):
    left = 0
    current_sum = 0
    count = 0
    for right in range(len(nums)):
        current_sum += nums[right]
        while current_sum > k and left <= right:
            current_sum -= nums[left]
            left += 1
        if current_sum == k:
            count += 1
    return count

Time Complexity:
    O(N) (each element is processed at most twice).

Space Complexity
    O(1) (no extra space used).

Limitation:
    Only works if all numbers are positive.
    If negative numbers are present, sliding window fails because shrinking the window may not reduce the sum.

Comparison of Approaches
Approach	            Time Complexity	Space Complexity	Works for Negative Numbers?
Brute Force	            O(N²)	        O(1)	            ✅ Yes
Prefix Sum + Hashmap	O(N)	        O(N)	            ✅ Yes
Sliding Window	        O(N)	        O(1)	            ❌ No (Only Positive)

Final Recommendation
    If the array has negative numbers → Use Prefix Sum + Hashmap (Optimal).
    If the array has only positive numbers → Sliding Window is slightly better (O(1) space).
    Brute Force is only for understanding, not for large inputs.

