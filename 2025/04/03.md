# Thursday, April 03 2025

## Tasks
- start recap for 1.5 hrs whatever i studied so far
- another 1.5 hrs finish till 29 number on playlist

## Notes


### Given an array nums of size n, return the majority element (appears more than ⌊n/2⌋ times).
Assume the majority element always exists.
Example:

Input: [3, 2, 3]
Output: 3 (appears 2/3 times)

#### Brute Force (O(n²))

Idea:
    For each element, count its occurrences.
    If count > n/2, return it.
```python
def majorityElement(nums):
    n = len(nums)
    for num in nums:
        count = sum(1 for x in nums if x == num)
        if count > n // 2:
            return num
```

Drawback: Too slow for large arrays (nested loops).

#### Better Approach (O(n log n)) 
    Sort the array → Majority element will always be at middle index (since it dominates >50%).

```python
def majorityElement(nums):
    nums.sort()
    return nums[len(nums) // 2]
```

Pros: Simple and works.
Cons: Sorting takes extra time (O(n log n)).

#### Optimal Approach: Moore's Voting Algorithm (O(n))

Idea:

    "Voting" mechanism:
        Assume the first element is the majority.
        Traverse the array:
            If same as candidate → increment votes.
            Else → decrement votes.
            If votes = 0 → switch candidate.
    The last remaining candidate is the majority.

```python
def moore_voting_problem(arr):
    if not arr:  # Handle empty array case
        return -1
    
    # First pass: Find potential candidate
    count = 0
    candidate = None
    
    for num in arr:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    
    # Second pass: Verify the candidate
    count_verify = 0
    for num in arr:
        if num == candidate:
            count_verify += 1
    
    if count_verify > len(arr) // 2:
        return candidate
    else:
        return -1  # Or None if no majority exists

# Test cases
print(moore_voting_problem([7,7,5,7,5,1,7]))  # Output: 7
print(moore_voting_problem([3,2,3]))         # Output: 3
print(moore_voting_problem([1,2,3]))         # Output: -1
print(moore_voting_problem([]))               # Output: -1
```

Why It Works:
    Majority element outnumbers all others combined, so it survives the vote cancellation.

Example Walkthrough:
nums = [3, 3, 4, 2, 3]

    Step 1: candidate=3, votes=1

    Step 2: candidate=3, votes=2

    Step 3: candidate=3, votes=1 (4 cancels one vote)

    Step 4: candidate=3, votes=0 (2 cancels another)

    Step 5: candidate=3, votes=1 (new 3 takes lead)
    Result: 3 (majority)

Key Takeaways

✅ Moore's Voting Algorithm is the fastest (O(n)) and most efficient for this problem.
✅ Sorting trick is a good fallback if you forget Moore’s.
❌ Avoid brute force in interviews—it’s too slow!

### Majority Element II (N/3 Rule) | Brute - Better - Optimal

Given an integer array nums, find all elements that appear more than ⌊N/3⌋ times (where N = len(nums)).
(Note: There can be at most two such elements.)
Example:
Input: nums = [3, 2, 3]  
Output: [3]  
Explanation:  
- 3 appears 2 times (> ⌊3/3⌋ = 1).  
- 2 appears 1 time (≤ 1), so it's not included.

#### Brute Force Approach (O(N²) Time | O(1) Space)
Idea:

    For each element, count its occurrences by traversing the entire array.

    If count > N/3, add it to the result (avoid duplicates).

Code:
python
Copy

def majorityElement(nums):
    n = len(nums)
    res = []
    for i in range(n):
        if nums[i] not in res:  # Avoid duplicates
            count = 0
            for j in range(n):
                if nums[j] == nums[i]:
                    count += 1
            if count > n // 3:
                res.append(nums[i])
    return res

Time Complexity:

    O(N²) (nested loops).

Space Complexity:

    O(1) (no extra space except output).

#### Better Approach (Hashmap) (O(N) Time | O(N) Space)
Idea:

    Use a hashmap to store frequencies.

    Return elements with frequency > N/3.

Code:
python
Copy

def majorityElement(nums):
    from collections import defaultdict
    freq = defaultdict(int)
    res = []
    n = len(nums)
    for num in nums:
        freq[num] += 1
    for num, count in freq.items():
        if count > n // 3:
            res.append(num)
    return res

Time Complexity:

    O(N) (single pass for counting + another pass for checking).

Space Complexity:

    O(N) (hashmap stores frequencies).

#### Optimal Approach (Boyer-Moore Voting Algorithm) (O(N) Time | O(1) Space)
Idea:

    Since at most two elements can appear > N/3 times, we track two candidates.

    Use vote cancellation (similar to Boyer-Moore for N/2 problem).

Steps:

    Initialize two candidates (cand1, cand2) and their counts.

    First Pass:

        For each number, update candidates and counts (like voting).

        If a new number appears, decrement both counts (cancellation).

    Second Pass:

        Verify if the candidates' counts > N/3.

Code:
def majorityElement(nums):
    cand1, cand2 = None, None
    count1, count2 = 0, 0
    res = []
    
    # First Pass: Find candidates
    for num in nums:
        if num == cand1:
            count1 += 1
        elif num == cand2:
            count2 += 1
        elif count1 == 0:
            cand1 = num
            count1 = 1
        elif count2 == 0:
            cand2 = num
            count2 = 1
        else:
            count1 -= 1
            count2 -= 1
    
    # Second Pass: Verify counts
    count1, count2 = 0, 0
    for num in nums:
        if num == cand1:
            count1 += 1
        elif num == cand2:
            count2 += 1
    
    n = len(nums)
    if count1 > n // 3:
        res.append(cand1)
    if count2 > n // 3:
        res.append(cand2)
    
    return res

Explanation:

    First Pass:

        cand1 and cand2 are potential majority elements.

        If a new number appears, it cancels out existing votes.

    Second Pass:

        Confirms if the candidates truly appear > N/3 times.

Time Complexity:

    O(N) (two passes over the array).

Space Complexity:

    O(1) (only a few variables used).

Comparison of Approaches
Approach	Time Complexity	Space Complexity	Notes
Brute Force	O(N²)	O(1)	Slow, not recommended
Hashmap	O(N)	O(N)	Works for all cases
Boyer-Moore Voting	O(N)	O(1)	Optimal, works in O(1) space
Final Recommendation

    Use Boyer-Moore Voting Algorithm (Optimal) for O(1) space.

    Hashmap is simpler but uses O(N) space.

    Brute Force is only for understanding.


### maximum subarray sum problem

#### Brute-Force Solution (O(n³) time)

def max_subarray_brute(arr):
    max_sum = -float('inf')
    n = len(arr)
    start = end = -1
    
    for i in range(n):
        for j in range(i, n):
            current_sum = sum(arr[i:j+1])
            if current_sum > max_sum:
                max_sum = current_sum
                start, end = i, j
    return max_sum, start, end

#### Better Solution (O(n²) time)

def max_subarray_better(arr):
    max_sum = -float('inf')
    n = len(arr)
    start = end = -1
    
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += arr[j]
            if current_sum > max_sum:
                max_sum = current_sum
                start, end = i, j
    return max_sum, start, end

#### Optimal Solution (Kadane's Algorithm - O(n) time)

def kadane_algo(arr):
    if not arr:  # Handle empty array case
        return 0, -1, -1
    
    maxi = arr[0]  # Initialize with first element instead of -1000
    sum = 0
    ans_start = ans_end = 0
    start = 0
    
    for i in range(len(arr)):
        if sum == 0:
            start = i
        sum += arr[i]
        if sum > maxi:
            maxi = sum
            ans_start = start
            ans_end = i
        if sum < 0:
            sum = 0
    if max_sum < 0:
        return 0, -1, -1  # Sum=0, no indices if mentioned in problem
    return maxi, ans_start, ans_end

print(kadane_algo([-2,-3,4,1,-1,-2,1,5,-3]))  # Output: (7, 2, 7)


### Rearrange Array Elements by Sign

Problem Varieties
Variety 1: Equal number of positives and negatives

Requirement: Rearrange the array so that every positive number is followed by a negative number (order of appearance must be maintained).
Variety 2: Unequal number of positives and negatives

Requirement: Rearrange with alternating signs, placing remaining elements at the end (order maintained).
Solutions
Variety 1: Equal Positives/Negatives
#### Brute Force (O(n) time, O(n) space)
def rearrange_alternate_equal(arr):
    positives = [x for x in arr if x > 0]
    negatives = [x for x in arr if x < 0]
    result = []
    for p, n in zip(positives, negatives):
        result.extend([p, n])
    return result

#### Optimal (O(n) time, O(n) space)
def rearrange_alternate_equal_optimal(arr):
    result = [0] * len(arr)
    pos_idx, neg_idx = 0, 1
    for num in arr:
        if num > 0:
            result[pos_idx] = num
            pos_idx += 2
        else:
            result[neg_idx] = num
            neg_idx += 2
    return result

Variety 2: Unequal Positives/Negatives
#### Brute Force (O(n) time, O(n) space)
def rearrange_alternate_unequal(arr):
    positives = [x for x in arr if x > 0]
    negatives = [x for x in arr if x < 0]
    result = []
    min_len = min(len(positives), len(negatives))
    for i in range(min_len):
        result.extend([positives[i], negatives[i]])
    # Add remaining elements
    result.extend(positives[min_len:] or negatives[min_len:])
    return result

#### Optimal (O(n) time, O(n) space)
def rearrange_alternate_unequal_optimal(arr):
    result = []
    pos, neg = [], []
    for num in arr:
        if num > 0:
            pos.append(num)
        else:
            neg.append(num)
    
    i, j = 0, 0
    # Alternate until one list is exhausted
    while i < len(pos) and j < len(neg):
        result.extend([pos[i], neg[j]])
        i += 1
        j += 1
    # Add remaining elements
    result.extend(pos[i:] or neg[j:])
    return result

Key Differences

    Equal Counts:
        Can directly place elements using index arithmetic
        Don't need to handle leftovers

    Unequal Counts:
        Need to track two separate lists
        Must handle remaining elements after alternation
        Order of remaining elements must be preserved

Time/Space Complexity
Approach	Time	Space	Best For
Brute Force	O(n)	O(n)	Readability
Optimal	   O(n)	    O(n)	Efficiency
Edge Cases
    All positives
    All negatives
    Empty array
    Single element array
    Mixed with zeros (if zeros are allowed)

The optimal solutions maintain O(n) time complexity while being more efficient in practice than the brute force approaches.


### Next Permutation Problem
Problem Statement
Given an array of integers, find the lexicographically next greater permutation of its elements. If no such permutation exists, return the lowest possible order (sorted in ascending order).
Solutions from Brute Force to Optimal

#### Brute Force Approach (O(n!×n) time)

def next_permutation_brute(arr):
    from itertools import permutations
    
    # Generate all permutations
    all_perms = sorted(list(set(permutations(arr))))
    
    # Find current permutation index
    current = tuple(arr)
    try:
        idx = all_perms.index(current)
    except ValueError:
        return sorted(arr)
    
    # Return next permutation or first if at end
    if idx + 1 < len(all_perms):
        return list(all_perms[idx + 1])
    else:
        return sorted(arr)

#### Better Approach (O(n²) time)

def next_permutation_better(arr):
    n = len(arr)
    pivot = -1
    
    # Find the pivot point
    for i in range(n-1, 0, -1):
        if arr[i] > arr[i-1]:
            pivot = i-1
            break
    
    if pivot == -1:
        return sorted(arr)
    
    # Find swap candidate
    for j in range(n-1, pivot, -1):
        if arr[j] > arr[pivot]:
            arr[pivot], arr[j] = arr[j], arr[pivot]
            break
    
    # Reverse the suffix
    arr[pivot+1:] = arr[pivot+1:][::-1]
    return arr

#### Optimal Approach (O(n) time)

def next_permutation_optimal(arr):
    n = len(arr)
    i = n - 2
    
    # Find first decreasing element
    while i >= 0 and arr[i] >= arr[i+1]:
        i -= 1
    
    if i >= 0:
        j = n - 1
        # Find element just larger than arr[i]
        while arr[j] <= arr[i]:
            j -= 1
        arr[i], arr[j] = arr[j], arr[i]
    
    # Reverse the suffix
    arr[i+1:] = arr[i+1:][::-1]
    return arr

Algorithm Breakdown

    Brute Force:
        Generates all permutations (extremely inefficient)
        Sorts them lexicographically
        Finds current permutation and returns next one

    Better Approach:
        Finds the pivot point where sequence decreases
        Swaps with next larger element in suffix
        Reverses the suffix after pivot

    Optimal Approach:
        Same logic as better approach but optimized:
            Single pass to find pivot
            Single pass to find swap candidate
            Single reversal operation

Complexity Analysis
Approach	Time Complexity	Space Complexity
Brute Force	O(n!×n)	O(n!)
Better	    O(n²)	O(1)
Optimal 	O(n)	O(1)
Example Walkthrough

Input: [1, 3, 2]

    Find pivot: 1 (at index 0, since 1 < 3)

    Find swap: 2 (first from end > 1)

    Swap: [2, 3, 1]

    Reverse suffix: [2, 1, 3] → Final result

Edge Cases

    Already last permutation: [3, 2, 1] → [1, 2, 3]

    Single element: [1] → [1]

    All equal elements: [1, 1, 1] → [1, 1, 1]

    Empty array: [] → []

The optimal solution is preferred as it handles all cases efficiently in linear time with constant space.


### Leaders in an Array
Problem Statement

A leader in an array is an element that is greater than or equal to all elements to its right. Find all leaders in the given array.
Solutions from Brute Force to Optimal

#### Brute Force Approach (O(n²) time, O(1) space)

def find_leaders_brute(arr):
    leaders = []
    n = len(arr)
    for i in range(n):
        is_leader = True
        for j in range(i+1, n):
            if arr[i] < arr[j]:
                is_leader = False
                break
        if is_leader:
            leaders.append(arr[i])
    return leaders

#### Optimal Approach (O(n) time, O(1) space)

def find_leaders_optimal(arr):
    leaders = []
    max_so_far = float('-inf')
    n = len(arr)
    
    # Traverse from right to left
    for i in range(n-1, -1, -1):
        if arr[i] >= max_so_far:
            leaders.append(arr[i])
            max_so_far = arr[i]
    
    # Return in original order
    return leaders[::-1]


### Longest Consecutive Sequence
Problem Statement

Given an unsorted array of integers, find the length of the longest sequence of consecutive numbers (in any order).
Solutions from Brute Force to Optimal

#### Brute Force Approach (O(n³) time, O(1) space)

def longest_consecutive_brute(nums):
    max_len = 0
    
    for num in nums:
        current_num = num
        current_len = 1
        
        # Check forward sequence
        while current_num + 1 in nums:
            current_num += 1
            current_len += 1
        
        max_len = max(max_len, current_len)
    
    return max_len

#### Better Approach (O(n log n) time, O(1) space)

def longest_consecutive_better(nums):
    if not nums:
        return 0
    
    nums.sort()
    max_len = 1
    current_len = 1
    
    for i in range(1, len(nums)):
        if nums[i] == nums[i-1] + 1:
            current_len += 1
            max_len = max(max_len, current_len)
        elif nums[i] != nums[i-1]:  # Skip duplicates
            current_len = 1
    
    return max_len

#### Optimal Approach (O(n) time, O(n) space)

def longest_consecutive_optimal(nums):
    num_set = set(nums)
    max_len = 0
    
    for num in num_set:
        # Only check if it's the start of a sequence
        if num - 1 not in num_set:
            current_num = num
            current_len = 1
            
            while current_num + 1 in num_set:
                current_num += 1
                current_len += 1
            
            max_len = max(max_len, current_len)
    
    return max_len

Explanation
Brute Force Approach:
    For each number, check if the next consecutive number exists
    Continue checking until the sequence breaks
    Time Complexity: O(n³) - For each number (n), worst case scan entire array (n) for n numbers
    Space Complexity: O(1) - No extra space needed

Better Approach
    Sort the array first
    Scan through looking for consecutive sequences
    Time Complexity: O(n log n) - Due to sorting
    Space Complexity: O(1) or O(n) depending on sort implementation

Optimal Approach:
    Store numbers in a hash set for O(1) lookups
    Only start counting sequences from numbers that are sequence starters (no num-1 exists)
    Time Complexity: O(n) - Each number checked at most twice
    Space Complexity: O(n) - For the hash set

Edge Cases

    Empty array: [] → 0
    Single element: [5] → 1
    All duplicates: [1,1,1] → 1
    Already consecutive: [1,2,3,4] → 4
    Negative numbers: [0,-1] → 2